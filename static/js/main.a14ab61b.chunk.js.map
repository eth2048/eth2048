{"version":3,"sources":["components/Button/Button.tsx","components/Board/context/BoardContext.tsx","components/Board/hooks/useBoard.ts","components/Board/models/Board.ts","components/Grid/Grid.tsx","components/Tile/Tile.tsx","hooks/usePrevProps.ts","components/Board/Board.tsx","components/Tile/models/Tile.ts","components/Game/hooks/useIds.ts","components/Game/hooks/useGame/reducer.ts","components/Game/hooks/useGame/useGame.ts","components/Game/Game.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["Button","_ref","children","onClick","_jsx","className","BoardContext","React","createContext","containerWidth","tileCount","defaultTileCount","BoardProvider","_ref$containerWidth","_ref$tileCount","Provider","value","useBoard","_useContext","useContext","Grid","_useBoard","_slicedToArray","length","cells","index","push","concat","renderGrid","Tile","position","zIndex","_useBoard2","_useState","useState","_useState2","scale","setScale","previousValue","ref","useRef","useEffect","current","usePrevProps","withinBoardBoundaries","invariant","shallHighlight","undefined","setTimeout","positionToPixels","style","top","left","transform","Board","tiles","_ref$tileCountPerRow","tileCountPerRow","tileWidth","boardWidth","tileList","map","_ref2","id","restProps","_objectWithoutProperties","_excluded","_objectSpread","width","_jsxs","seqId","initialState","byIds","hasChanged","inMotion","GameReducer","state","action","type","_defineProperty","tile","_toConsumableArray","_state$tiles","_action$source$id","source","_action$destination$i","destination","restTiles","_toPropertyKey","filter","useGame","isInitialRender","_useIds","nextId","_useReducer","useReducer","_useReducer2","dispatch","createTile","useCallback","throttledMergeTile","mergeTile","updateTile","retrieveTileMap","tileMap","Array","tileCountPerRowOrColumn","fill","forEach","positionToIndex","findEmptyTiles","reduce","result","tileId","indexToPosition","generateRandomTile","emptyTiles","Math","floor","random","move","retrieveTileIdsPerRowOrColumn","calculateFirstFreeIndex","maxIndex","_loop","rowOrColumnIndex","availableTileIds","previousTile","mergedTilesCount","nonEmptyTileIndex","currentTile","mergeWith","hasXChanged","hasYChanged","didTileMove","bind","_this","rowIndex","tileIndex","tileInRowIndex","howManyMerges","_","reverse","maxIndexInRow","columnIndex","tileInColumnIndex","maxIndexInColumn","Game","_useGame","_useGame2","moveLeft","moveRight","moveUp","moveDown","throttledHandleKeyDown","useThrottledCallback","e","preventDefault","code","leading","trailing","window","addEventListener","removeEventListener","App","Date","date","setDate","toISOString","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.a14ab61b.chunk.js","sourcesContent":["import React from \"react\";\r\nimport \"./button.less\";\r\n\r\ntype Props = {\r\n  children: any;\r\n  onClick?: () => void;\r\n};\r\n\r\nexport const Button = ({ children, onClick }: Props) => {\r\n  return (\r\n    <button className=\"button\" onClick={onClick}>\r\n      {children}\r\n    </button>\r\n  );\r\n};\r\n","import React from \"react\";\r\nimport { tileCount as defaultTileCount } from \"../index\";\r\n\r\nexport const BoardContext = React.createContext({\r\n  containerWidth: 0,\r\n  tileCount: defaultTileCount,\r\n});\r\n\r\ntype Props = {\r\n  containerWidth: number;\r\n  tileCount: number;\r\n  children: any;\r\n};\r\n\r\nexport const BoardProvider = ({\r\n  children,\r\n  containerWidth = 0,\r\n  tileCount = defaultTileCount,\r\n}: Props) => {\r\n  return (\r\n    <BoardContext.Provider value={{ containerWidth, tileCount }}>\r\n      {children}\r\n    </BoardContext.Provider>\r\n  );\r\n};\r\n","import { useContext } from \"react\";\r\nimport { BoardContext } from \"../context/BoardContext\";\r\n\r\n/**\r\n * Returns the properties of the board such as tile container width or tile count.\r\n */\r\nexport const useBoard = () => {\r\n  const { containerWidth, tileCount } = useContext(BoardContext);\r\n\r\n  return [containerWidth, tileCount] as [number, number];\r\n};\r\n","import { pixelSize } from \"../../../styles\";\r\n\r\n/**\r\n * The number of tiles per row and column.\r\n * IMPORTANT! Check styles before changing this value!\r\n *\r\n * @constant {number}\r\n */\r\nexport const tileCount = 4;\r\n\r\n/**\r\n * The duration of every animation in ms.\r\n * IMPORTANT! Check styles before modyfing this value!\r\n *\r\n * @constant {number} ms\r\n */\r\nexport const animationDuration = 250;\r\n\r\n/**\r\n * The board margin (left, right, top, bottom).\r\n */\r\nexport const boardMargin = 2 * pixelSize;\r\n","import React from \"react\";\r\nimport { useBoard } from \"../Board\";\r\n\r\nimport \"./grid.less\";\r\n\r\nexport const Grid = () => {\r\n  const [, tileCount] = useBoard();\r\n\r\n  const renderGrid = () => {\r\n    const length = tileCount * tileCount;\r\n    const cells = [] as JSX.Element[];\r\n\r\n    for (let index = 0; index < length; index += 1) {\r\n      cells.push(<div key={`${index}`} className={`grid-cell`} />);\r\n    }\r\n\r\n    return cells;\r\n  };\r\n\r\n  return <div className=\"grid\">{renderGrid()}</div>;\r\n};\r\n","import React, { useEffect, useState } from \"react\";\r\nimport invariant from \"tiny-invariant\";\r\nimport { usePrevProps } from \"../../hooks/usePrevProps\";\r\nimport { useBoard } from \"../Board\";\r\nimport \"./tile.less\";\r\n\r\ntype Props = {\r\n  // tile value - 2, 4, 8, 16, 32, ..., 2048.∂\r\n  value: number;\r\n  // an array containing the x and y index on the board.\r\n  position: [number, number];\r\n  // the order of tile on the tile stack.\r\n  zIndex: number;\r\n};\r\n\r\nexport const Tile = ({ value, position, zIndex }: Props) => {\r\n  // retrieves board properties\r\n  const [containerWidth, tileCount] = useBoard();\r\n  //  state required to animate the highlight\r\n  const [scale, setScale] = useState(1);\r\n\r\n  // the previous value (prop) - it is undefined if it is a new tile.\r\n  const previousValue = usePrevProps<number>(value);\r\n\r\n  // check if tile is within the board boundries\r\n  const withinBoardBoundaries =\r\n    position[0] < tileCount && position[1] < tileCount;\r\n  invariant(withinBoardBoundaries, \"Tile out of bound\");\r\n\r\n  // if it is a new tile...\r\n  const isNew = previousValue === undefined;\r\n  // ...or its value has changed...\r\n  const hasChanged = previousValue !== value;\r\n  // ... then the tile should be highlighted.\r\n  const shallHighlight = isNew || hasChanged;\r\n\r\n  // useEffect will decide if highlight should be triggered.\r\n  useEffect(() => {\r\n    if (shallHighlight) {\r\n      setScale(1.1);\r\n      setTimeout(() => setScale(1), 100);\r\n    }\r\n  }, [shallHighlight, scale]);\r\n\r\n  /**\r\n   * Converts tile position from array index to pixels.\r\n   */\r\n  const positionToPixels = (position: number) => {\r\n    return (position / tileCount) * (containerWidth as number);\r\n  };\r\n\r\n  // all animations come from CSS transition, and we pass them as styles\r\n  const style = {\r\n    top: positionToPixels(position[1]),\r\n    left: positionToPixels(position[0]),\r\n    transform: `scale(${scale})`,\r\n    zIndex,\r\n  };\r\n\r\n  return (\r\n    <div className={`tile tile-${value}`} style={style}>\r\n      {value}\r\n    </div>\r\n  );\r\n};\r\n","import { useEffect, useRef } from \"react\";\r\n\r\n/**\r\n * `usePrevProps` stores the previous value of the prop.\r\n *\r\n * @link https://blog.logrocket.com/how-to-get-previous-props-state-with-react-hooks/\r\n * @param {K} value\r\n * @returns {K | undefined}\r\n */\r\nexport const usePrevProps = <K = any>(value: K) => {\r\n  const ref = useRef<K>();\r\n\r\n  useEffect(() => {\r\n    ref.current = value;\r\n  });\r\n\r\n  return ref.current;\r\n};\r\n","import React from \"react\";\r\nimport { BoardProvider } from \"./context/BoardContext\";\r\nimport { boardMargin, tileCount as defaultTileCount } from \"./models/Board\";\r\nimport { Grid } from \"../Grid\";\r\nimport { TileMeta, tileTotalWidth, Tile } from \"../Tile\";\r\nimport \"./board.less\";\r\n\r\ntype Props = {\r\n  tiles: TileMeta[];\r\n  tileCountPerRow: number;\r\n};\r\n\r\nexport const Board = ({ tiles, tileCountPerRow = defaultTileCount }: Props) => {\r\n  // container width = tile width * tile count per row\r\n  const containerWidth = tileTotalWidth * tileCountPerRow;\r\n  // board width = container width + margin\r\n  const boardWidth = containerWidth + boardMargin;\r\n\r\n  // render all tiles on the board\r\n  const tileList = tiles.map(({ id, ...restProps }) => (\r\n    <Tile key={`tile-${id}`} {...restProps} zIndex={id} />\r\n  ));\r\n\r\n  return (\r\n    <div className=\"board\" style={{ width: boardWidth }}>\r\n      <BoardProvider\r\n        containerWidth={containerWidth}\r\n        tileCount={tileCountPerRow}\r\n      >\r\n        <div className=\"tile-container\">{tileList}</div>\r\n        <Grid />\r\n      </BoardProvider>\r\n    </div>\r\n  );\r\n};\r\n","import { pixelSize } from \"../../../styles\";\r\n\r\nexport type TileMeta = {\r\n  id: number;\r\n  position: [number, number];\r\n  value: number;\r\n  mergeWith?: number;\r\n};\r\n\r\nconst tileMargin = 2 * pixelSize;\r\n\r\nconst tileWidthMultiplier = 12.5;\r\n\r\nconst tileWidth = tileWidthMultiplier * pixelSize;\r\n\r\nexport const tileTotalWidth = tileWidth + tileMargin;\r\n","let seqId = 1;\r\n\r\n/**\r\n * Returns next sequential number.\r\n */\r\nexport const useIds = () => {\r\n  const nextId = () => {\r\n    return seqId++;\r\n  };\r\n\r\n  return [nextId];\r\n};\r\n","import { TileMeta } from \"../../../Tile\";\r\n\r\ntype State = {\r\n  tiles: {\r\n    [id: number]: TileMeta;\r\n  };\r\n  inMotion: boolean;\r\n  hasChanged: boolean;\r\n  byIds: number[];\r\n};\r\n\r\nexport const initialState: State = {\r\n  tiles: {},\r\n  byIds: [],\r\n  hasChanged: false,\r\n  inMotion: false,\r\n};\r\n\r\ntype Action =\r\n  | { type: \"CREATE_TILE\"; tile: TileMeta }\r\n  | { type: \"UPDATE_TILE\"; tile: TileMeta }\r\n  | { type: \"MERGE_TILE\"; source: TileMeta; destination: TileMeta }\r\n  | { type: \"START_MOVE\" }\r\n  | { type: \"END_MOVE\" };\r\n\r\nexport const GameReducer = (state: State, action: Action) => {\r\n  switch (action.type) {\r\n    case \"CREATE_TILE\":\r\n      return {\r\n        ...state,\r\n        tiles: {\r\n          ...state.tiles,\r\n          [action.tile.id]: action.tile,\r\n        },\r\n        byIds: [...state.byIds, action.tile.id],\r\n        hasChanged: false,\r\n      };\r\n    case \"UPDATE_TILE\":\r\n      return {\r\n        ...state,\r\n        tiles: {\r\n          ...state.tiles,\r\n          [action.tile.id]: action.tile,\r\n        },\r\n        hasChanged: true,\r\n      };\r\n    case \"MERGE_TILE\":\r\n      const {\r\n        [action.source.id]: source,\r\n        [action.destination.id]: destination,\r\n        ...restTiles\r\n      } = state.tiles;\r\n      return {\r\n        ...state,\r\n        tiles: {\r\n          ...restTiles,\r\n          [action.destination.id]: {\r\n            id: action.destination.id,\r\n            value: action.source.value + action.destination.value,\r\n            position: action.destination.position,\r\n          },\r\n        },\r\n        byIds: state.byIds.filter((id) => id !== action.source.id),\r\n        hasChanged: true,\r\n      };\r\n    case \"START_MOVE\":\r\n      return {\r\n        ...state,\r\n        inMotion: true,\r\n      };\r\n    case \"END_MOVE\":\r\n      return {\r\n        ...state,\r\n        inMotion: false,\r\n      };\r\n    default:\r\n      return state;\r\n  }\r\n};\r\n","import { useCallback, useEffect, useReducer, useRef } from \"react\";\r\nimport {\r\n  animationDuration,\r\n  tileCount as tileCountPerRowOrColumn,\r\n} from \"../../../Board\";\r\nimport { TileMeta } from \"../../../Tile\";\r\nimport { useIds } from \"../useIds\";\r\nimport { GameReducer, initialState } from \"./reducer\";\r\n\r\nexport const useGame = () => {\r\n  const isInitialRender = useRef(true);\r\n  const [nextId] = useIds();\r\n  // state\r\n  const [state, dispatch] = useReducer(GameReducer, initialState);\r\n  const { tiles, byIds, hasChanged, inMotion } = state;\r\n\r\n  const createTile = useCallback(\r\n    ({ position, value }: Partial<TileMeta>) => {\r\n      const tile = {\r\n        id: nextId(),\r\n        position,\r\n        value,\r\n      } as TileMeta;\r\n      dispatch({ type: \"CREATE_TILE\", tile });\r\n    },\r\n    [nextId]\r\n  );\r\n\r\n  const mergeTile = (source: TileMeta, destination: TileMeta) => {\r\n    dispatch({ type: \"MERGE_TILE\", source, destination });\r\n  };\r\n\r\n  // A must-have to keep the sliding animation if the action merges tiles together.\r\n  const throttledMergeTile = (source: TileMeta, destination: TileMeta) => {\r\n    setTimeout(() => mergeTile(source, destination), animationDuration);\r\n  };\r\n\r\n  const updateTile = (tile: TileMeta) => {\r\n    dispatch({ type: \"UPDATE_TILE\", tile });\r\n  };\r\n\r\n  const didTileMove = (source: TileMeta, destination: TileMeta) => {\r\n    const hasXChanged = source.position[0] !== destination.position[0];\r\n    const hasYChanged = source.position[1] !== destination.position[1];\r\n\r\n    return hasXChanged || hasYChanged;\r\n  };\r\n\r\n  const retrieveTileMap = useCallback(() => {\r\n    const tileMap = new Array(\r\n      tileCountPerRowOrColumn * tileCountPerRowOrColumn\r\n    ).fill(0) as number[];\r\n\r\n    byIds.forEach((id) => {\r\n      const { position } = tiles[id];\r\n      const index = positionToIndex(position);\r\n      tileMap[index] = id;\r\n    });\r\n\r\n    return tileMap;\r\n  }, [byIds, tiles]);\r\n\r\n  const findEmptyTiles = useCallback(() => {\r\n    const tileMap = retrieveTileMap();\r\n\r\n    const emptyTiles = tileMap.reduce((result, tileId, index) => {\r\n      if (tileId === 0) {\r\n        return [...result, indexToPosition(index) as [number, number]];\r\n      }\r\n\r\n      return result;\r\n    }, [] as [number, number][]);\r\n\r\n    return emptyTiles;\r\n  }, [retrieveTileMap]);\r\n\r\n  const generateRandomTile = useCallback(() => {\r\n    const emptyTiles = findEmptyTiles();\r\n\r\n    if (emptyTiles.length > 0) {\r\n      const index = Math.floor(Math.random() * emptyTiles.length);\r\n      const position = emptyTiles[index];\r\n\r\n      createTile({ position, value: 2 });\r\n    }\r\n  }, [findEmptyTiles, createTile]);\r\n\r\n  const positionToIndex = (position: [number, number]) => {\r\n    return position[1] * tileCountPerRowOrColumn + position[0];\r\n  };\r\n\r\n  const indexToPosition = (index: number) => {\r\n    const x = index % tileCountPerRowOrColumn;\r\n    const y = Math.floor(index / tileCountPerRowOrColumn);\r\n    return [x, y];\r\n  };\r\n\r\n  type RetrieveTileIdsPerRowOrColumn = (rowOrColumnIndex: number) => number[];\r\n\r\n  type CalculateTileIndex = (\r\n    tileIndex: number,\r\n    tileInRowIndex: number,\r\n    howManyMerges: number,\r\n    maxIndexInRow: number\r\n  ) => number;\r\n\r\n  const move = (\r\n    retrieveTileIdsPerRowOrColumn: RetrieveTileIdsPerRowOrColumn,\r\n    calculateFirstFreeIndex: CalculateTileIndex\r\n  ) => {\r\n    // new tiles cannot be created during motion.\r\n    dispatch({ type: \"START_MOVE\" });\r\n\r\n    const maxIndex = tileCountPerRowOrColumn - 1;\r\n\r\n    // iterates through every row or column (depends on move kind - vertical or horizontal).\r\n    for (\r\n      let rowOrColumnIndex = 0;\r\n      rowOrColumnIndex < tileCountPerRowOrColumn;\r\n      rowOrColumnIndex += 1\r\n    ) {\r\n      // retrieves tiles in the row or column.\r\n      const availableTileIds = retrieveTileIdsPerRowOrColumn(rowOrColumnIndex);\r\n\r\n      // previousTile is used to determine if tile can be merged with the current tile.\r\n      let previousTile: TileMeta | undefined;\r\n      // mergeCount helps to fill gaps created by tile merges - two tiles become one.\r\n      let mergedTilesCount = 0;\r\n\r\n      // interate through available tiles.\r\n      availableTileIds.forEach((tileId, nonEmptyTileIndex) => {\r\n        const currentTile = tiles[tileId];\r\n\r\n        // if previous tile has the same value as the current one they should be merged together.\r\n        if (\r\n          previousTile !== undefined &&\r\n          previousTile.value === currentTile.value\r\n        ) {\r\n          const tile = {\r\n            ...currentTile,\r\n            position: previousTile.position,\r\n            mergeWith: previousTile.id,\r\n          } as TileMeta;\r\n\r\n          // delays the merge by 250ms, so the sliding animation can be completed.\r\n          throttledMergeTile(tile, previousTile);\r\n          // previous tile must be cleared as a single tile can be merged only once per move.\r\n          previousTile = undefined;\r\n          // increment the merged counter to correct position for the consecutive tiles to get rid of gaps\r\n          mergedTilesCount += 1;\r\n\r\n          return updateTile(tile);\r\n        }\r\n\r\n        // else - previous and current tiles are different - move the tile to the first free space.\r\n        const tile = {\r\n          ...currentTile,\r\n          position: indexToPosition(\r\n            calculateFirstFreeIndex(\r\n              rowOrColumnIndex,\r\n              nonEmptyTileIndex,\r\n              mergedTilesCount,\r\n              maxIndex\r\n            )\r\n          ),\r\n        } as TileMeta;\r\n\r\n        // previous tile become the current tile to check if the next tile can be merged with this one.\r\n        previousTile = tile;\r\n\r\n        // only if tile has changed its position it will be updated\r\n        if (didTileMove(currentTile, tile)) {\r\n          return updateTile(tile);\r\n        }\r\n      });\r\n    }\r\n\r\n    // wait until the end of all animations.\r\n    setTimeout(() => dispatch({ type: \"END_MOVE\" }), animationDuration);\r\n  };\r\n\r\n  const moveLeftFactory = () => {\r\n    const retrieveTileIdsByRow = (rowIndex: number) => {\r\n      const tileMap = retrieveTileMap();\r\n\r\n      const tileIdsInRow = [\r\n        tileMap[rowIndex * tileCountPerRowOrColumn + 0],\r\n        tileMap[rowIndex * tileCountPerRowOrColumn + 1],\r\n        tileMap[rowIndex * tileCountPerRowOrColumn + 2],\r\n        tileMap[rowIndex * tileCountPerRowOrColumn + 3],\r\n      ];\r\n\r\n      const nonEmptyTiles = tileIdsInRow.filter((id) => id !== 0);\r\n      return nonEmptyTiles;\r\n    };\r\n\r\n    const calculateFirstFreeIndex = (\r\n      tileIndex: number,\r\n      tileInRowIndex: number,\r\n      howManyMerges: number,\r\n      _: number\r\n    ) => {\r\n      return (\r\n        tileIndex * tileCountPerRowOrColumn + tileInRowIndex - howManyMerges\r\n      );\r\n    };\r\n\r\n    return move.bind(this, retrieveTileIdsByRow, calculateFirstFreeIndex);\r\n  };\r\n\r\n  const moveRightFactory = () => {\r\n    const retrieveTileIdsByRow = (rowIndex: number) => {\r\n      const tileMap = retrieveTileMap();\r\n\r\n      const tileIdsInRow = [\r\n        tileMap[rowIndex * tileCountPerRowOrColumn + 0],\r\n        tileMap[rowIndex * tileCountPerRowOrColumn + 1],\r\n        tileMap[rowIndex * tileCountPerRowOrColumn + 2],\r\n        tileMap[rowIndex * tileCountPerRowOrColumn + 3],\r\n      ];\r\n\r\n      const nonEmptyTiles = tileIdsInRow.filter((id) => id !== 0);\r\n      return nonEmptyTiles.reverse();\r\n    };\r\n\r\n    const calculateFirstFreeIndex = (\r\n      tileIndex: number,\r\n      tileInRowIndex: number,\r\n      howManyMerges: number,\r\n      maxIndexInRow: number\r\n    ) => {\r\n      return (\r\n        tileIndex * tileCountPerRowOrColumn +\r\n        maxIndexInRow +\r\n        howManyMerges -\r\n        tileInRowIndex\r\n      );\r\n    };\r\n\r\n    return move.bind(this, retrieveTileIdsByRow, calculateFirstFreeIndex);\r\n  };\r\n\r\n  const moveUpFactory = () => {\r\n    const retrieveTileIdsByColumn = (columnIndex: number) => {\r\n      const tileMap = retrieveTileMap();\r\n\r\n      const tileIdsInColumn = [\r\n        tileMap[columnIndex + tileCountPerRowOrColumn * 0],\r\n        tileMap[columnIndex + tileCountPerRowOrColumn * 1],\r\n        tileMap[columnIndex + tileCountPerRowOrColumn * 2],\r\n        tileMap[columnIndex + tileCountPerRowOrColumn * 3],\r\n      ];\r\n\r\n      const nonEmptyTiles = tileIdsInColumn.filter((id) => id !== 0);\r\n      return nonEmptyTiles;\r\n    };\r\n\r\n    const calculateFirstFreeIndex = (\r\n      tileIndex: number,\r\n      tileInColumnIndex: number,\r\n      howManyMerges: number,\r\n      _: number\r\n    ) => {\r\n      return (\r\n        tileIndex +\r\n        tileCountPerRowOrColumn * (tileInColumnIndex - howManyMerges)\r\n      );\r\n    };\r\n\r\n    return move.bind(this, retrieveTileIdsByColumn, calculateFirstFreeIndex);\r\n  };\r\n\r\n  const moveDownFactory = () => {\r\n    const retrieveTileIdsByColumn = (columnIndex: number) => {\r\n      const tileMap = retrieveTileMap();\r\n\r\n      const tileIdsInColumn = [\r\n        tileMap[columnIndex + tileCountPerRowOrColumn * 0],\r\n        tileMap[columnIndex + tileCountPerRowOrColumn * 1],\r\n        tileMap[columnIndex + tileCountPerRowOrColumn * 2],\r\n        tileMap[columnIndex + tileCountPerRowOrColumn * 3],\r\n      ];\r\n\r\n      const nonEmptyTiles = tileIdsInColumn.filter((id) => id !== 0);\r\n      return nonEmptyTiles.reverse();\r\n    };\r\n\r\n    const calculateFirstFreeIndex = (\r\n      tileIndex: number,\r\n      tileInColumnIndex: number,\r\n      howManyMerges: number,\r\n      maxIndexInColumn: number\r\n    ) => {\r\n      return (\r\n        tileIndex +\r\n        tileCountPerRowOrColumn *\r\n          (maxIndexInColumn - tileInColumnIndex + howManyMerges)\r\n      );\r\n    };\r\n\r\n    return move.bind(this, retrieveTileIdsByColumn, calculateFirstFreeIndex);\r\n  };\r\n\r\n  useEffect(() => {\r\n    if (isInitialRender.current) {\r\n      createTile({ position: [0, 1], value: 2 });\r\n      createTile({ position: [0, 2], value: 2 });\r\n      isInitialRender.current = false;\r\n      return;\r\n    }\r\n\r\n    if (!inMotion && hasChanged) {\r\n      generateRandomTile();\r\n    }\r\n  }, [hasChanged, inMotion, createTile, generateRandomTile]);\r\n\r\n  const tileList = byIds.map((tileId) => tiles[tileId]);\r\n\r\n  const moveLeft = moveLeftFactory();\r\n  const moveRight = moveRightFactory();\r\n  const moveUp = moveUpFactory();\r\n  const moveDown = moveDownFactory();\r\n\r\n  return [tileList, moveLeft, moveRight, moveUp, moveDown] as [\r\n    TileMeta[],\r\n    () => void,\r\n    () => void,\r\n    () => void,\r\n    () => void\r\n  ];\r\n};\r\n","import React, { useEffect } from \"react\";\r\nimport { useThrottledCallback } from \"use-debounce\";\r\n\r\nimport { useGame } from \"./hooks/useGame\";\r\nimport { Board, animationDuration, tileCount } from \"../Board\";\r\n\r\nexport const Game = () => {\r\n  const [tiles, moveLeft, moveRight, moveUp, moveDown] = useGame();\r\n\r\n  const handleKeyDown = (e: KeyboardEvent) => {\r\n    // disables page scrolling with keyboard arrows\r\n    e.preventDefault();\r\n\r\n    switch (e.code) {\r\n      case \"ArrowLeft\":\r\n        moveLeft();\r\n        break;\r\n      case \"ArrowRight\":\r\n        moveRight();\r\n        break;\r\n      case \"ArrowUp\":\r\n        moveUp();\r\n        break;\r\n      case \"ArrowDown\":\r\n        moveDown();\r\n        break;\r\n    }\r\n  };\r\n\r\n  // protects the reducer from being flooded with events.\r\n  const throttledHandleKeyDown = useThrottledCallback(\r\n    handleKeyDown,\r\n    animationDuration,\r\n    { leading: true, trailing: false }\r\n  );\r\n\r\n  useEffect(() => {\r\n    window.addEventListener(\"keydown\", throttledHandleKeyDown);\r\n\r\n    return () => {\r\n      window.removeEventListener(\"keydown\", throttledHandleKeyDown);\r\n    };\r\n  }, [throttledHandleKeyDown]);\r\n\r\n  return <Board tiles={tiles} tileCountPerRow={tileCount} />;\r\n};\r\n","import React, { useState } from \"react\";\r\nimport { Button } from \"./components/Button\";\r\nimport { Game } from \"./components/Game\";\r\n\r\nimport \"./App.less\";\r\n\r\n/* eslint-disable react/jsx-no-target-blank */\r\nexport const App = () => {\r\n  const [date, setDate] = useState<Date>(new Date());\r\n\r\n  const handleRestart = () => {\r\n    setDate(new Date());\r\n  };\r\n\r\n  return (\r\n    <div className=\"App\">\r\n      <div className=\"header\">\r\n        <div>\r\n          <h1>2048 ETH</h1>\r\n        </div>\r\n        <div>\r\n          <Button onClick={handleRestart}>Restart</Button>\r\n        </div>\r\n      </div>\r\n      <Game key={date.toISOString()} />\r\n      <div>\r\n      <p>\r\n      <b>This game (2048) was built for degens.</b> so I hope you can learn your lesson from it.\r\n        </p>\r\n        <p>\r\n          <b>Wondering what is next for the game?</b> You can find a plan here:\r\n        </p>\r\n        <ul>\r\n          <li>\r\n              Dapp Intergration soon\r\n          </li>\r\n          <li>\r\n            Chat soon\r\n          </li>\r\n          <li>\r\n              Scoreboard soon\r\n          </li>\r\n          <li>\r\n              Reward soon\r\n          </li>\r\n          <li>\r\n              Mooning soon\r\n          </li>\r\n        </ul>\r\n      </div>\r\n      <div className=\"footer\">\r\n        Made with ❤️ by{\" \"}\r\n          bunch of degens\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n/* eslint-enable react/jsx-no-target-blank */\r\n","import { ReportHandler } from \"web-vitals\";\r\n\r\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\r\n  if (onPerfEntry && onPerfEntry instanceof Function) {\r\n    import(\"web-vitals\").then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\r\n      getCLS(onPerfEntry);\r\n      getFID(onPerfEntry);\r\n      getFCP(onPerfEntry);\r\n      getLCP(onPerfEntry);\r\n      getTTFB(onPerfEntry);\r\n    });\r\n  }\r\n};\r\n\r\nexport default reportWebVitals;\r\n","import React from \"react\";\r\nimport ReactDOM from \"react-dom\";\r\nimport { App } from \"./App\";\r\nimport reportWebVitals from \"./reportWebVitals\";\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById(\"root\")\r\n);\r\n\r\n// If you want to start measuring performance in your app, pass a function\r\n// to log results (for example: reportWebVitals(console.log))\r\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\r\nreportWebVitals();\r\n"],"sourceRoot":""}